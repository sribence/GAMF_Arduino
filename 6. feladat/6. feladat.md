
# üîß Szerv√≥motorok √©s Gyorsul√°sm√©r≈ë Integr√°l√°sa

Ebben a projektben t√∂bbf√©le eszk√∂zt kombin√°lunk: **szerv√≥motorokat**, **ultrahangos t√°vols√°gm√©r≈ët**, **gyorsul√°sm√©r≈ët** √©s **joystick modult**. A c√©l az, hogy k√ºl√∂nb√∂z≈ë vez√©rl√©si logik√°kat √©s szenzor-integr√°ci√≥t gyakoroljunk. A v√©g√©n ak√°r egy **gimbal-szimul√°ci√≥** is megval√≥s√≠that√≥.

---

## üß∞ Sz√ºks√©ges alkatr√©szek

| Eszk√∂z                  | Megjegyz√©s                             |
|-------------------------|----------------------------------------|
| 2 db szerv√≥motor        | Pl. SG90 vagy MG996R                   |
| HC-SR04 t√°vols√°gm√©r≈ë    | Ultrahangos √©rz√©kel≈ë                   |
| MPU6050 vagy ADXL345    | Gyorsul√°sm√©r≈ë                          |
| Joystick modul          | K√©t tengelyes, X/Y + SW                |
| Arduino UNO             |                                        |
| Breadboard + t√°pk√°belek | 5V t√°p biztos√≠t√°sa szerv√≥knak k√ºl√∂n√∂sen |

---

## ‚öôÔ∏è Projekt l√©p√©sek

üì∑ ALAP Bek√∂t√©s
![..](/6.%20feladat/6-2.png)
> _Figure 1: 2 db servo bek√∂t√©se arduinora


### 1. K√©t szerv√≥motor vez√©rl√©se

```cpp
#include <Servo.h>

Servo szervo1;
Servo szervo2;

void setup() {
  szervo1.attach(9);
  szervo2.attach(10);
}

void loop() {
  for (int fok = 0; fok <= 180; fok += 5) {
    szervo1.write(fok);
    szervo2.write(180 - fok);
    delay(100);
  }
}
```
> [!NOTE]
> Ez a k√≥d ellent√©tes ir√°nyba mozgatja a k√©t szerv√≥t. Haszn√°lhat√≥ sebess√©g- vagy mozg√°sszimul√°ci√≥hoz.

### 2. Szerv√≥ vez√©rl√©se t√°vols√°g alapj√°n

üì∑ kieg√©sz√≠tett Bek√∂t√©s
![..](/6.%20feladat/6-3.png)
> _Figure 1: 2 db servo bek√∂t√©se ULTRASONIC t√°vols√°gm√©r≈ë mell√©

  ```cpp
#include <Servo.h>

Servo szervo;
int trig = 7;
int echo = 6;
long ido;
int tavolsag;

void setup() {
  szervo.attach(9);
  pinMode(trig, OUTPUT);
  pinMode(echo, INPUT);
}

void loop() {
  digitalWrite(trig, LOW);
  delayMicroseconds(2);
  digitalWrite(trig, HIGH);
  delayMicroseconds(10);
  digitalWrite(trig, LOW);

  ido = pulseIn(echo, HIGH);
  tavolsag = ido * 0.034 / 2;

  int fok = map(tavolsag, 5, 50, 0, 180);
  fok = constrain(fok, 0, 180);
  szervo.write(fok);

  delay(200);
}
```
> [!NOTE]
> Ez a k√≥d a szerv√≥ poz√≠ci√≥j√°t a m√©rt t√°vols√°g alapj√°n √°ll√≠tja be. P√©ld√°ul: min√©l k√∂zelebb van egy t√°rgy, ann√°l ink√°bb balra fordul.

---

### 3. Szerv√≥ k√∂rbeforgat√°sa, m√≠g t√°vols√°g < 20 cm

```cpp
#include <Servo.h>

Servo szervo;
int trig = 7;
int echo = 6;

void setup() {
  szervo.attach(9);
  pinMode(trig, OUTPUT);
  pinMode(echo, INPUT);
}

void loop() {
  for (int fok = 0; fok <= 180; fok++) {
    szervo.write(fok);
    delay(20);

    digitalWrite(trig, LOW);
    delayMicroseconds(2);
    digitalWrite(trig, HIGH);
    delayMicroseconds(10);
    digitalWrite(trig, LOW);

    long ido = pulseIn(echo, HIGH);
    int tav = ido * 0.034 / 2;

    if (tav < 20) {
      break;
    }
  }
}
```
> [!NOTE]
> A szerv√≥ fokozatosan forog, de le√°ll, ha a t√°vols√°g 20 cm al√° cs√∂kken. Haszn√°lhat√≥ akad√°lyk√∂vet√©shez.
---



### 4. Gyorsul√°sm√©r≈ë haszn√°lata v√≠zszint √©rz√©kel√©shez (MPU6050)
üì∑ Gyro bek√∂t√©se
![..](/6.%20feladat/6-4.png)
> _Figure 1: Servo mozgat√°s gyorsul√°sm√©r≈ëvel!


```cpp
#include <Wire.h>
#include <MPU6050.h>
#include <Servo.h>

MPU6050 mpu;
Servo szervo;

void setup() {
  Wire.begin();
  mpu.initialize();
  szervo.attach(9);
}

void loop() {
  int x = mpu.getAccelerationX();
  int fok = map(x, -17000, 17000, 0, 180);
  fok = constrain(fok, 0, 180);
  szervo.write(fok);
  delay(100);
}

```
> [!NOTE]
> Az getAccelerationX() a gyorsul√°s √©rt√©k√©t adja X tengelyen. Ebb≈ël k√∂vetkeztethet√ºnk a d≈ël√©ssz√∂gre ‚Äì haszn√°lhat√≥ pl. egy t√°lca v√≠zszintbe hoz√°s√°hoz.

---

### 5. K√©t szerv√≥ ir√°ny√≠t√°sa joystickkel

üì∑ Joystick bek√∂t√©se pluszba
![..](/6.%20feladat/6-5-2.png)
> _Figure 1: Joystickkel is kieg√©sz√≠thetj√ºk a feladatot m√©g!

```cpp
#include <Servo.h>

Servo szervoX;
Servo szervoY;

int joyX = A0;
int joyY = A1;

void setup() {
  szervoX.attach(9);
  szervoY.attach(10);
}

void loop() {
  int x = analogRead(joyX);
  int y = analogRead(joyY);

  int fokX = map(x, 0, 1023, 0, 180);
  int fokY = map(y, 0, 1023, 0, 180);

  szervoX.write(fokX);
  szervoY.write(fokY);

  delay(20);
}

```
> [!NOTE]
> A joystick modul k√©t ir√°nyba (X/Y) mozgathat√≥, ezekb≈ël a poz√≠ci√≥kb√≥l vez√©relhet≈ë k√©t szerv√≥motor. T√∂k√©letes alap egy mini robotkar vagy kamera√°llv√°ny ir√°ny√≠t√°s√°hoz.

---

## üåü Extra √∂tlet: Gimbal-szimul√°ci√≥ szerv√≥kkal
Kombin√°ld az MPU6050 gyorsul√°sm√©r≈ë + k√©t szerv√≥ + joystick vagy szoftveres visszacsatol√°s logik√°j√°t! A c√©l: a szerv√≥k automatikusan tarts√°k a poz√≠ci√≥t, hogy a platform mindig v√≠zszintes vagy egy ir√°nyban √°lljon ‚Äì pont mint egy gimbal.

> [!NOTE]
> A mozg√°sk√∂vet√©sn√©l fontos az √©rz√©kel≈ë gyors √©s stabil adatfeldolgoz√°sa, kisz≈±rve az apr√≥ rezg√©seket. A PID vez√©rl√©s bevezet√©se halad√≥ opci√≥ lehet.







