# üìè IR vs Ultrahangos T√°vols√°gm√©r√©s ‚Äì Arduino Projekt

Ebben a projektben k√©t n√©pszer≈± t√°vols√°gm√©r≈ë szenzort hasonl√≠tunk √∂ssze: egy **IR t√°vols√°gm√©r≈ët** (pl. Sharp GP2Y0A) √©s az **ultrahangos HC-SR04-et**. A c√©l a t√°vols√°gm√©r√©s megval√≥s√≠t√°sa, pontoss√°g n√∂vel√©se, valamint LED-f√©nyer≈ë szab√°lyoz√°sa a m√©rt √©rt√©k alapj√°n.

---

## üß∞ Alkatr√©szek

| Eszk√∂z             | Megjegyz√©s                     |
|--------------------|--------------------------------|
| Arduino UNO        |                                |
| HC-SR04 szenzor    | Ultrahangos                    |
| IR t√°vols√°gm√©r≈ë    | Pl. Sharp GP2Y0A21YK0F         |
| LCD kijelz≈ë (opci√≥) | Vagy soros port               |
| LED + ellen√°ll√°s   | F√©nyer≈ëszab√°lyoz√°shoz          |
| Breadboard + k√°belek|                               |

---

## üîå Bek√∂t√©si √°bra

![8x8 matrix connecting diagram](/4.%20feladat/4-1.png)

> √Åbra: A HC-SR04 bek√∂t√©se ‚Äì Trig (kimenet), Echo (bemenet);

## Hogy m≈±k√∂dik az Ultrahangos t√°vols√°gm√©r√©s? 

Az ‚Äûultrahang‚Äù olyan hanghull√°mokat jelent, amelyek frekvenci√°ja 20 000 Hz f√∂l√∂tt van, √≠gy az emberi f√ºl sz√°m√°ra nem hallhat√≥k. B√°r mi nem halljuk, sok √°llat ‚Äì p√©ld√°ul a kuty√°k √©s denev√©rek ‚Äì k√©pes √©rz√©kelni ezeket, √©s ak√°r t√°j√©koz√≥d√°sra is haszn√°lj√°k ≈ëket.

![image](https://github.com/user-attachments/assets/220df431-dfa8-4422-b6c2-f13b4c18ea78)

> Hangfrekvenci√°k √°br√°zolva

![image](https://lastminuteengineers.com/wp-content/uploads/arduino/HC-SR04-Ultrasonic-Sensor-Working-Echo-when-no-Obstacle.gif)

> T√°vols√°gm√©r√©s hang alapj√°n

**A t√°vols√°g kisz√°m√≠t√°sa ultrahangos szenzorral**

A t√°vols√°got √∫gy sz√°moljuk ki, hogy megn√©zz√ºk, **mennyi ideig tartott a visszaver≈ëd√∂tt ultrahanghull√°m meg√©rkez√©se** ‚Äì vagyis milyen **sz√©les** (hossz√∫) volt az **echo jel**. Ehhez a j√≥l ismert k√©pletet haszn√°ljuk a fizik√°b√≥l:

`T√°vols√°g = Sebess√©g √ó Id≈ë`

P√©lda: Tegy√ºk fel, hogy egy t√°rgy van az √©rz√©kel≈ë el≈ëtt, √©s az echo l√°bon egy 500 mikrosekundumos (¬µs) jelet kapunk. A hang sebess√©ge leveg≈ëben k√∂r√ºlbel√ºl 340 m/s, de mivel mi centim√©terben √©s mikrosekundumban szeretn√©nk sz√°molni, ezt √°tv√°ltjuk:

`340 m/s = 0,034 cm/¬µs`

Ezut√°n a k√©plet:

`T√°vols√°g = 0,034 cm/¬µs √ó 500 ¬µs = 17 cm`

Viszont van m√©g egy fontos l√©p√©s! Ez a 17 cm val√≥j√°ban az oda-vissza √∫t, mert a hang elmegy a t√°rgyig √©s vissza is j√∂n. Ez√©rt az igazi t√°vols√°got √∫gy kapjuk meg, ha ezt elosztjuk kett≈ëvel:

`Val√≥di t√°vols√°g = 17 cm √∑ 2 = 8,5 cm`

√çgy teh√°t az objektum 8,5 cm-re van az √©rz√©kel≈ët≈ël.












---

## üî¨ Projekt l√©p√©sek

### 1. HC-SR04 szenzor haszn√°lata

```cpp
// Az eszk√∂z csatlakoz√°sa
int trig = 2;
int echo = 3;

// Seg√©dv√°ltoz√≥k
long ido;
float tavolsag;

void setup() 
{
    // Csatlakoz√°s a soros kapcsolathoz
    Serial.begin(9600);

    // Ki- √©s bemenetek be√°ll√≠t√°sa
    pinMode(trig, OUTPUT);
    pinMode(echo, INPUT);
}

void loop() 
{
    // Adott hossz√∫s√°g√∫ jelet k√ºld√ºnk hogy haszn√°ljuk az eszk√∂zt
    digitalWrite(trig, LOW);
    delayMicroseconds(2);
    digitalWrite(trig, HIGH);
    delayMicroseconds(10);
    digitalWrite(trig, LOW);

    // Beolvassuk a jel hossz√°t √©s abb√≥l kisz√°moljuk a t√°vols√°got
    ido = pulseIn(echo, HIGH);
    tavolsag = ido * 0.034 / 2;

    // Ki√≠rjuk a t√°vols√°got
    Serial.print("Tavolsag: ");
    Serial.print(tavolsag);
    Serial.println(" cm");

    // V√°runk 0.2 m√°sodpercet
    delay(200);
}
```

> [!TIP]
> Az ido * 0.034 / 2 k√©plet a hang terjed√©si sebess√©g√©b≈ël ad√≥dik. A m√©rt impulzushossz a visszaver≈ëd√∂tt jel alapj√°n sz√°m√≠t√≥dik.
---

### 2. IR szenzor haszn√°lata (digit√°lis)

Az IR t√°vols√°gm√©r√©s igen gyakori, √°ra, alacsony komplexit√°sa √©s pontoss√°ga miatt. Csak alacsony t√°vols√°gokon m≈±k√∂dik j√≥l, teh√°t t√∂bb m√©teres tartom√°nyban ritk√°n haszn√°lj√°k m√°r. 
Viszont a mi IR √©rz√©kel≈ënk jelenleg `digit√°lis` jelet ad nek√ºnk vissza. Ez sajnos t√°vols√°g m√©r√©s√©re nem tud szolg√°lni, csak olyan adatra, hogy l√°t-e maga el≈ëtt **valamit**. 
Sokszor ez az inform√°ci√≥ is hasznos, p√©ld√°ul Robot Aut√≥ v√©szf√©kez√©se alapulhat erre, de t√°j√©koz√≥d√°sra nem igaz√°n haszn√°lhat√≥. 

![8x8 matrix connecting diagram](/4.%20feladat/4-2.png)

> √Åbra: A IR √©rz√©kel≈ë bek√∂t√©se ‚Äì digit√°lis bemenetre. 


```cpp
// Az eszk√∂z csatlakoz√°sa
int irPin = 13;

// Seg√©dv√°ltoz√≥k a t√°vols√°g sz√°m√≠t√°s√°hoz
int ertek;

void setup()
{
    // Csatlakoz√°s be√°ll√≠t√°sa bementk√©nt
    pinMode(irPin, INPUT);

    // Csatlakoz√°s a soros kapcsolathoz
    Serial.begin(9600);
}

void loop() 
{
    // Beolvassuk ha t√°vols√°gon bel√ºl van-e a t√°rgy
    ertek = digitalRead(irPin);

    // Ha t√°vols√°gon bel√ºl van akkor LOW jelet kapunk vissza
    if (ertek == LOW)
    {
        Serial.println("Tavolsagon belul.");
    }
    else
    {
        Serial.println("Tavolsagon kivul.");      
    }
    
    // V√°runk 0.2 m√°sodpercet
    delay(200);
}
```
>[!NOTE]
>Az analog IR szenzorok m≈±k√∂d√©se nem line√°ris, de eg√©sz pontos t√°vols√°gm√©r√©st lehet 10‚Äì80 cm k√∂z√∂tt megval√≥s√≠tani vel√ºk.
---
### 3. Pontos√≠t√°s: √Åtlagol√°s t√∂bb m√©r√©sb≈ël
```cpp
// Az eszk√∂z csatlakoz√°sa
int trig = 2;
int echo = 3;

// Seg√©dv√°ltoz√≥k
long ido;
float tavolsag;

void setup() {
    // Csatlakoz√°s a soros kapcsolathoz
    Serial.begin(9600);

    // Ki- √©s bemenetek be√°ll√≠t√°sa
    pinMode(trig, OUTPUT);
    pinMode(echo, INPUT);
}

void loop() 
{
    // Ki√≠rjuk az atlagolt t√°vols√°got
    Serial.print("Tavolsag: ");
    Serial.print(atlagMeres());
    Serial.println(" cm");

    // V√°runk 0.2 m√°sodpercet
    delay(200);
}

float meres()
{
    // Adott hossz√∫s√°g√∫ jelet k√ºld√ºnk hogy haszn√°ljuk az eszk√∂zt
    digitalWrite(trig, LOW);
    delayMicroseconds(2);
    digitalWrite(trig, HIGH);
    delayMicroseconds(10);
    digitalWrite(trig, LOW);

    // Beolvassuk a jel hossz√°t √©s abb√≥l kisz√°moljuk a t√°vols√°got
    ido = pulseIn(echo, HIGH);
    tavolsag = ido * 0.034 / 2;

    return tavolsag;
}

float atlagMeres()
{
    float osszeg = 0;
    for (int i = 0; i < 5; i++) {
        osszeg += meres();
        delay(50);
    }
    return osszeg / 5;
}
```

> [!NOTE]
> Egyszer≈± √°tlagol√°ssal kisz≈±rhet≈ëk v√©letlenszer≈± hib√°k, de mozg√≥√°tlaggal m√©g stabilabb √©rt√©ket kaphatunk.
---
### 4. Mozg√≥√°tlag implement√°l√°sa
```cpp
#define MERET 5

// Az eszk√∂z csatlakoz√°sa
int trig = 2;
int echo = 3;

// Seg√©dv√°ltoz√≥k
long ido;
float tavolsag;
float ertekek[MERET];
int index = 0;

void setup() {
    // Csatlakoz√°s a soros kapcsolathoz
    Serial.begin(9600);

    // Ki- √©s bemenetek be√°ll√≠t√°sa
    pinMode(trig, OUTPUT);
    pinMode(echo, INPUT);
}

void loop() 
{
    // Ki√≠rjuk az atlagolt t√°vols√°got
    Serial.print("Tavolsag: ");
    Serial.print(mozgoAtlag());
    Serial.println(" cm");

    // V√°runk 0.2 m√°sodpercet
    delay(200);
}

float meres()
{
    // Adott hossz√∫s√°g√∫ jelet k√ºld√ºnk hogy haszn√°ljuk az eszk√∂zt
    digitalWrite(trig, LOW);
    delayMicroseconds(2);
    digitalWrite(trig, HIGH);
    delayMicroseconds(10);
    digitalWrite(trig, LOW);

    // Beolvassuk a jel hossz√°t √©s abb√≥l kisz√°moljuk a t√°vols√°got
    ido = pulseIn(echo, HIGH);
    tavolsag = ido * 0.034 / 2;

    return tavolsag;
}

float mozgoAtlag() {
    ertekek[index] = meres();
    index = (index + 1) % MERET;

    float osszeg = 0;
    for (int i = 0; i < MERET; i++) {
        osszeg += ertekek[i];
    }
    return osszeg / MERET;
}
```
> [!NOTE]
> A mozg√≥√°tlag "cs√∫sz√≥ablakk√©nt" m≈±k√∂dik, amely folyamatosan friss√ºl √©s kiegyenl√≠ti a hirtelen kiugr√°sokat.
---




### 5. Extra: Kijelz≈ën a m√©rt adatok megjelen√≠t√©se


![8x8 matrix connecting diagram](/4.%20feladat/4-3.png)

> √Åbra: Kijelz≈ëvel eg√©sz√≠tj√ºk ki az √°ramk√∂r√ºnket!




```cpp
#include <LiquidCrystal.h> // Telep√≠teni kell a k√∂nyvt√°rat

// Kijelz≈ë "l√©trehoz√°sa"
LiquidCrystal kijelzo(11, 12, 6, 7, 4, 5);

// Szenzor csatlakoz√°sa
int trig = 2;
int echo = 3;

// Seg√©dv√°ltoz√≥k
long ido;
float tavolsag;

void setup() 
{
    // Kijelz≈ë elind√≠t√°sa
    kijelzo.begin(8, 2);

    // Szenzor csatlakoz√°sainak be√°ll√≠t√°sa ki- √©s bemenetre
    pinMode(trig, OUTPUT);
    pinMode(echo, INPUT);
}

void loop() {
    // T√°vols√°g m√©r√©se
    digitalWrite(trig, LOW);
    delayMicroseconds(2);
    digitalWrite(trig, HIGH);
    delayMicroseconds(10);
    digitalWrite(trig, LOW);

    ido = pulseIn(echo, HIGH);
    tavolsag = ido * 0.034 / 2;

    // Kijelz≈ë friss√≠t√©se
    kijelzo.clear();
    kijelzo.setCursor(0, 0);
    kijelzo.print("Tav:");
    kijelzo.setCursor(0, 1);
    kijelzo.print((int)tavolsag);
    kijelzo.print("cm");

    delay(500);
}


```
> [!NOTE]
> A kijelzo.clear() minden ciklusban t√∂rli a kijelz≈ët ‚Äì ez villog√°st okozhat. Helyette haszn√°lhatsz fix poz√≠ci√≥ra √≠r√°st √©s kor√°bbi karakterek fel√ºl√≠r√°s√°t.
Ha I2C LCD-t haszn√°lsz, a LiquidCrystal_I2C k√∂nyvt√°rat √©s kijelzo.init(); / kijelzo.backlight(); h√≠v√°sokat kell haszn√°lni a begin() helyett.

## Az Ultrahangos t√°vols√°gm√©r√©s limit√°ci√≥i
Mik a korl√°tai az ultrahangos t√°vols√°gm√©r≈ënek?

Az HC-SR04 ultrahangos szenzor nagyon pontos √©s j√≥l haszn√°lhat√≥, k√ºl√∂n√∂sen az olcs√≥bb √©rz√©kel≈ëk k√∂z√∂tt. De ez nem jelenti azt, hogy minden helyzetben t√∂k√©letesen m≈±k√∂dik. √çme n√©h√°ny fontos korl√°t, amire figyelni kell:

- 4 m√©ter f√∂l√∂tt m√°r nem tud pontosan m√©rni, s≈ët, lehet, hogy semmit sem √©rz√©kel.
  
![image](https://github.com/user-attachments/assets/14912b5a-324b-4a11-b420-c35895cdf63e)

- Ha a t√°rgy ferd√©n √°ll a szenzorhoz k√©pest, az ultrahang elcs√∫szhat oldalra, √©s nem ver≈ëdik vissza.
  
![image](https://github.com/user-attachments/assets/cce03250-52aa-4778-991e-83e986df1f7d)

- Nagyon kicsi t√°rgyak lehet, hogy nem verik vissza el√©gg√© a hangot, √≠gy a szenzor nem √©rz√©keli ≈ëket.
  
![image](https://github.com/user-attachments/assets/bad3a682-70fa-424a-8b76-aa6fb1e8489c)

- Ha a szenzort t√∫l k√∂zel tessz√ºk a f√∂ldh√∂z, el≈ëfordulhat, hogy a padl√≥r√≥l visszaver≈ëd≈ë jelet √©rz√©keli, nem a t√°rgyat.

- A puha vagy szivacsos fel√ºletek (pl. pl√ºss, textil) elnyelhetik a hangot, √≠gy neh√©z ≈ëket √©szlelni.

![image](https://github.com/user-attachments/assets/81ec8b4a-aab5-4921-a7f9-425b7cf52e45)






 ## üìà Fejleszt√©si √∂tletek
- LCD kijelz≈ëre is ki√≠ratni az √©rt√©keket
- Egyszerre figyelni IR √©s ultrahangos m√©r√©st, √©s √∂sszehasonl√≠tani
- Hangsz√≥r√≥ figyelmeztet√©s, ha t√∫l k√∂zel van valami
- OLED grafikon a t√°vols√°gv√°ltoz√°sr√≥l

## üéì Mit tanulunk ebb≈ël?
- Meg√©rtj√ºk, hogyan m≈±k√∂dik k√©tf√©le t√°vols√°gm√©r≈ë szenzor: az ultrahangos √©s az infrav√∂r√∂s (IR). Mindkett≈ëvel m√©rhet√ºnk t√°vols√°got, de m√°shogy √©rz√©kelik a k√∂rnyezetet.
- Megtanuljuk, hogyan kell a HC-SR04 szenzort vez√©relni: hogyan k√ºld ultrahangot, √©s hogyan sz√°moljuk ki a visszaver≈ëd√©s ideje alapj√°n a t√°vols√°got
- Megtanuljuk, hogyan olvassunk be anal√≥g √©rt√©keket IR szenzor eset√©n, √©s hogyan lehet azokat k√©plettel val√≥di t√°vols√°gg√° alak√≠tani.
- Meg√©rtj√ºk, mi√©rt van sz√ºks√©g √°tlagol√°sra √©s mozg√≥√°tlagra: ezek seg√≠tenek, hogy a m√©r√©sek ne ugr√°ljanak, hanem stabil, megb√≠zhat√≥ √©rt√©ket kapjunk.
- Megismerj√ºk az LCD kijelz≈ë haszn√°lat√°t, amivel a m√©rt √©rt√©keket val√≥s id≈ëben ki tudjuk √≠rni, √≠gy interakt√≠vabb√° v√°lik a projekt√ºnk.
- Megtanuljuk, hogy a szenzorok nem t√©vedhetetlenek: vannak korl√°tai az ultrahangos m√©r√©snek, pl. rossz visszaver≈ëd√©s, sz√∂g vagy anyag eset√©n ‚Äì vagyis kritikusan is kell tudnunk gondolkodni a m√©r√©si adatokr√≥l.
- Megval√≥s√≠tunk egy val√≥s p√©ld√°t arra, hogyan lehet egy m√©rt √©rt√©ket tov√°bb feldolgozni ‚Äì p√©ld√°ul egy LED f√©nyerej√©t szab√°lyozni a t√°vols√°g alapj√°n.
- √ñsszess√©g√©ben r√°√©rz√ºnk arra, hogy m√©r√©s + adatfeldolgoz√°s + megjelen√≠t√©s egy√ºtt adja azt, amit egy m√©r≈ërendszert≈ël elv√°runk.
