# üìè IR vs Ultrahangos T√°vols√°gm√©r√©s ‚Äì Arduino Projekt

Ebben a projektben k√©t n√©pszer≈± t√°vols√°gm√©r≈ë szenzort hasonl√≠tunk √∂ssze: egy **IR t√°vols√°gm√©r≈ët** (pl. Sharp GP2Y0A) √©s az **ultrahangos HC-SR04-et**. A c√©l a t√°vols√°gm√©r√©s megval√≥s√≠t√°sa, pontoss√°g n√∂vel√©se, valamint LED-f√©nyer≈ë szab√°lyoz√°sa a m√©rt √©rt√©k alapj√°n.

---

## üß∞ Alkatr√©szek

| Eszk√∂z             | Megjegyz√©s                     |
|--------------------|--------------------------------|
| Arduino UNO        |                                |
| HC-SR04 szenzor    | Ultrahangos                    |
| IR t√°vols√°gm√©r≈ë    | Pl. Sharp GP2Y0A21YK0F         |
| LCD kijelz≈ë (opci√≥) | Vagy soros port               |
| LED + ellen√°ll√°s   | F√©nyer≈ëszab√°lyoz√°shoz          |
| Breadboard + k√°belek|                               |

---

## üîå Bek√∂t√©si √°bra

![8x8 matrix connecting diagram](/2.%20feladat/2-2-1.png)

> [!NOTE]
> A k√©pet cser√©ld le a megfelel≈ë bek√∂t√©si rajzra: HC-SR04 ‚Äì Trig (kimenet), Echo (bemenet); IR ‚Äì 3-pines t√°p + anal√≥g kimenet.

---

## üî¨ Projekt l√©p√©sek

### 1. HC-SR04 szenzor haszn√°lata

```cpp
int trig = 9;
int echo = 10;
long ido;
float tavolsag;

void setup() {
  Serial.begin(9600);
  pinMode(trig, OUTPUT);
  pinMode(echo, INPUT);
}

void loop() {
  digitalWrite(trig, LOW);
  delayMicroseconds(2);
  digitalWrite(trig, HIGH);
  delayMicroseconds(10);
  digitalWrite(trig, LOW);

  ido = pulseIn(echo, HIGH);
  tavolsag = ido * 0.034 / 2;

  Serial.print("Tavolsag: ");
  Serial.print(tavolsag);
  Serial.println(" cm");

  delay(200);
}
```

> [!NOTE]
> Az ido * 0.034 / 2 k√©plet a hang terjed√©si sebess√©g√©b≈ël ad√≥dik. A m√©rt impulzushossz a visszaver≈ëd√∂tt jel alapj√°n sz√°m√≠t√≥dik.

2. IR szenzor haszn√°lata (anal√≥g)

```cpp
int irPin = A0;
int ertek;
float tavolsag;

void loop() {
  ertek = analogRead(irPin);
  tavolsag = 12343.85 * pow(ertek, -1.15);  // k√∂zel√≠t≈ë k√©plet
  Serial.print("IR tavolsag: ");
  Serial.print(tavolsag);
  Serial.println(" cm");
  delay(200);
}
```
>[!NOTE]
>Az IR szenzor nem line√°ris, de a fenti k√©plet egyes t√≠pusokhoz (pl. Sharp GP2Y0A21YK0F) j√≥ k√∂zel√≠t√©st ad 10‚Äì80 cm k√∂z√∂tt.

3. Pontos√≠t√°s: √Åtlagol√°s t√∂bb m√©r√©sb≈ël
```cpp
float atlagoltTavolsag() {
  float osszeg = 0;
  for (int i = 0; i < 5; i++) {
    osszeg += mertesHC_SR04();
    delay(50);
  }
  return osszeg / 5;
}
```

> [!NOTE]
> Egyszer≈± √°tlagol√°ssal kisz≈±rhet≈ëk v√©letlenszer≈± hib√°k, de mozg√≥√°tlaggal m√©g stabilabb √©rt√©ket kaphatunk.

4. Mozg√≥√°tlag implement√°l√°sa
```cpp
#define MERET 5
float ertekek[MERET];
int index = 0;

float mozgoAtlag(float uj) {
  ertekek[index] = uj;
  index = (index + 1) % MERET;

  float osszeg = 0;
  for (int i = 0; i < MERET; i++) {
    osszeg += ertekek[i];
  }
  return osszeg / MERET;
}
```
> [!NOTE]
> A mozg√≥√°tlag "cs√∫sz√≥ablakk√©nt" m≈±k√∂dik, amely folyamatosan friss√ºl √©s kiegyenl√≠ti a hirtelen kiugr√°sokat.

5. Extra: LED f√©nyer≈ë t√°vols√°gt√≥l f√ºgg≈ëen

```cpp
int ledPin = 5;

void loop() {
  float tav = atlagoltTavolsag(); // vagy mozgoAtlag()
  int fenyeroseg = map(tav, 5, 30, 255, 0);
  fenyeroseg = constrain(fenyeroseg, 0, 255);

  analogWrite(ledPin, fenyeroseg);

  delay(100);
}
```
> [!NOTE]
> A map() √°talak√≠tja a t√°vols√°got 0‚Äì255 k√∂z√©. A constrain() biztos√≠tja, hogy az √©rt√©k ne l√©pje t√∫l a LED PWM hat√°rait.
